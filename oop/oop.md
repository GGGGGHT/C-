# 面向对象程序设计

面向对象程序设计基于三个基本概念：`数据抽象`、`继承`和`动态绑定`.<br/>

- 封装可以将类的接口与实现分离.<br/>
- 继承可以定义相似的类型并对其相似关系建模.<br/>
- 多态可以在一定程序上忽略相似类型的区别,而以统一的方式使用它们的对象

## 数据抽象(封装)

## 继承

通过`继承`联系在一直的类构成一种层次关系.通常在层次关系的根部有一个`基类`,其他类则直接或间接地从基类继承而来,通过继承得到的类称为`派生类`,
`基类`负责定义在层次关系中所有类共同拥有的成员，而每个`派生类`定义各自特有的成员

## 动态绑定(多态)

可以将基类的指针或引用绑定到派生类对象上. 例如,可以用Quote& 指向一个Bulk_quote对象,也可以将一个Bulk_quote对象的地址赋给一个Quote*

当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型. 动态绑定只有当我们通过指针或引用调用虚函数时才会发生.

### `静态类型`与`动态类型`

表达式的`静态类型`在编译时总是已知的,它是变量声明时的类型或表达式生成的类型; `动态类型`是变量或表达式表示的内存中的对象类型,直到运行时才可知

```c++
// item静态类型是Quote& 动态类型依赖于item绑定的实参.
double ret = item.net_price(n);
```

如果表达式即不是引用也不是指针,则它的动态类型永远与静态类型一致.<br/>
派生类向基类的自动类型转换只对`指针`或`引用`类型有效.在派生类类型和基类类型之间不存在这样的转换.

存在继承关系的类型之间的转换规则:

1. 从派生类向基类的类型转换只对指针或引用类型有效
2. 基类向派生类不存在隐式类型转换
3. 派生类向基类的类型转换也可能会由于访问受限而变得不可行

### 名字查找与继承

<b>函数调用的解析过程<b/>
```c++
p->mem();
obj.mem();
```
1. 首先确定p(或obj)的静态类型. 因为我们调用的是一个成员,所以该类型必然是类类型
2. 在p(或obj)的静态类型对应的类中查找mem. 如果没找到,则依次在直接基类中不断查找直至到达继承链的顶端. 如果亢奋完该类及其基类仍然找不到, 则编译器将报错
3. 找到了mem, 就进行常规的类型检查以确认对于当前找到的mem,本次调用是否合法.
4. 假设调用合法,则编译器将根据调用的是否是虚函数而产生不同的代码 
   - 如果mem是虚函数且我们是通过引用或指针进行调用,则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本,依据是对象的动态类型.
   - 如果不是虚函数或者我们是通过对象进行的调用,则编译器将产生一个常规函数调用. 