# 泛型算法

顺序容器只定义了很少的操作,如添加/删除元素,访问首/尾元素,确定容器是否为空以及获得指向首/尾元素位置的迭代器<br/>

标准库并未给每个容器都定义成员函数来实现更高级的操作(如查找特定元素,替换或删除一个特定值..),而是定义了一组<b>泛型算法</b>:
称它们为"算法"是因为它们实现了一些经典算法的公共接口,如排序和搜索,称他们为"泛型"是因为它们可以用于不同类型的元素和多种容器类型

泛型算法本身不会执行容器的操作,它们只会运行于迭代器之上,执行迭代器的操作.

泛型算法总是使用两个参数来表示范围,两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器<br/>
用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长.确保算法不会施工图访问第二个序列中不存在的元素是程序员的责任
## 只读算法

一些算法只会读取其输入范围内的元素,而不改变元素.
- find 就是这样一种算法
- accumulate 同样也是 accumulate(vec.cbegin(),vec.cend(),0) 计算 vec 中所有元素的和  accumulate的第三个参数 的类型决定了函数中使用哪个加法运算符以及返回值的类型
- equal 用于确定两个序列是否保存相同的值. 它将第一个序列中的每个元素与第二个序列中的对应元素进行比较

## 写容器元素的算法

一些算法会自己向输入范围写入元素
- fill(vec.begin(),vec.end(), 0) 接受一对迭代器表示一个范围,fill 将给定的这个值赋予输入序列中的每个元素
- fill_n
- back_inserter 保证算法有足够元素空间来容纳输出数据的方式是使用插入迭代器.


一些算法接受一个迭代器来指出一个单独的目的位置.这些算法将新值赋予一个序列中的元素,该序列从目的位置

### 拷贝算法

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法.此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置,传递给copy的目的序列至少要包含与输入序列一样的多的元素
