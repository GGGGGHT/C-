# 面向对象程序设计

面向对象程序设计基于三个基本概念：`数据抽象`、`继承`和`动态绑定`.<br/>
- 封装可以将类的接口与实现分离.<br/>
- 继承可以定义相似的类型并对其相似关系建模.<br/>
- 多态可以在一定程序上忽略相似类型的区别,而以统一的方式使用它们的对象

## 数据抽象(封装)

## 继承
通过`继承`联系在一直的类构成一种层次关系.通常在层次关系的根部有一个`基类`,其他类则直接或间接地从基类继承而来,通过继承得到的类称为`派生类`,
`基类`负责定义在层次关系中所有类共同拥有的成员，而每个`派生类`定义各自特有的成员
## 动态绑定(多态)

可以将基类的指针或引用绑定到派生类对象上. 
例如,可以用Quote& 指向一个Bulk_quote对象,也可以将一个Bulk_quote对象的地址赋给一个Quote*

当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型.
动态绑定只有当我们通过指针或引用调用虚函数时才会发生.

### `静态类型`与`动态类型`

表达式的`静态类型`在编译时总是已知的,它是变量声明时的类型或表达式生成的类型; `动态类型`是变量或表达式表示的内存中的对象类型,直到运行时才可知 

```c++
// item静态类型是Quote& 动态类型依赖于item绑定的实参.
double ret = item.net_price(n);
```

如果表达式即不是引用也不是指针,则它的动态类型永远与静态类型一致.<br/>
派生类向基类的自动类型转换只对`指针`或`引用`类型有效.在派生类类型和基类类型之间不存在这样的转换.

存在继承关系的类型之间的转换规则:
1. 从派生类向基类的类型转换只对指针或引用类型有效
2. 基类向派生类不存在隐式类型转换
3. 派生类向基类的类型转换也可能会由于访问受限而变得不可行              